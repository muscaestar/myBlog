#+HUGO_FRONT_MATTER_FORMAT: yaml
#+AUTHOR: Muscaestar
#+HUGO_BASE_DIR: ~/myBlog/
#+HUGO_AUTO_SET_LASTMOD: t

* About Me / 关于
** About Me
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_HUGO_SECTION: en/page
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle Muscaestar
:END:
I'm a newbie who bumped into the programming world a few years ago and decided to
stay forever. Now I'm studying IT in University. This blog shall witness my passion
and efforts.

I love Vim and Doom-Emacs. But since I realized these endless tool-customizing time didn't actually
benefit my core skills, I've started to focus on 'decent real-matters'.

Start from, data structures and algorithms...

** 关于
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_HUGO_SECTION: zh-CN/page
:EXPORT_HUGO_LOCALE: zh
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle Muscaestar
:END:
用“无知无畏”来形容几年前的文转理的决定，不足为过。但现在我确信，代码和编程会是自己一生
的热爱，脚下这条路虽然困难重重，但是对目标的明确追求，一定好过曾经的迷茫享乐。目
前 IT 硕士在读，我想用博客记录下自己的热情与努力。

我非常喜欢 Vim 和 Doom-Emacs，愿意花费很多时间调配它们。现在意识到，工具永
远只是工具，才终于沉下心来，去看书，看源码，苦练基本功。

就从算法与数据结构开始...
* DONE Start a Multi Language Blog with Hugo on Github Pages / 用 Hugo 构建一个多语言博客（Github 部署） :blog:Hugo:
CLOSED: [2019-12-29 Sun 17:50]
** DONE Start a Multi Language Blog with Hugo on Github Pages
CLOSED: [2019-12-27 Sun 17:37]
:PROPERTIES:
:EXPORT_FILE_NAME: MultiLanguage-Blog-Hugo-Github
:EXPORT_HUGO_SECTION: en/post
:END:
Hugo is a handy framework for generating static website, which suits for normal
blog. You can easily write blogs with various markdown languages and organize
them with lots of features. This article will show you how I create this blog with it. I will focus on:
1. Installation and Deployment
2. Multi-Language Setting
#+hugo: more
*** Why Hugo?
Fast. Flexible. Open Source. Go... Plenty of reasons for trying it. Actually, I
don't care. For me, the key point is that it works well with Emacs, org-mode.
But this article won't mention any of Emacs. Before I integrate Hugo with Emacs,
what I did is just using Hugo like a normal person. And it's just soooo easy and
convenient to use.

So, the purpose of this article is just to show you how to use Hugo with just a
little knowledge about command line.

*** Before start
Three things to ensure a smooth experience:
1. Basic knowledge of shell
2. Ability to check official document
3. Basic usage of Github

Operating System: =macOS=

*** Installation and Deployment
**** Install
Run the commands below. Checkout document for details: [[https://gohugo.io/getting-started/quick-start/][Quick Start]]
#+BEGIN_SRC shell
$ brew install hugo    # Homebrew
$ hugo version         # Verify, in my case v0.60.1
$ hugo new site <projectName> # Create project directory
$ cd <projectName>     # Go to the new directory
$ git init             # Version control
#+END_SRC
Then make it a Github repository. No further instruction here.

**** Add theme
In my case, I choose [[https://themes.gohugo.io/beautifulhugo/][Beautiful Hugo]]
as my theme.

Notice that in my configurations below, some of them maybe required specifically by this theme.

Install the theme:
#+BEGIN_SRC shell
$ git submodule add https://github.com/halogenica/beautifulhugo.git themes/beautifulhugo
# use theme's example config file as a start point
$ cat themes/beautifulhugo/exampleSite/config.toml >> config.toml
#+END_SRC
Before you modify the configuration now, you may need to explore the
files under =<project>/themes/beautifulhugo/exampleSite=. It helps you to
understand the whole structure.

Play around with your =config.toml=. Refer to document for more details:
[[https://gohugo.io/getting-started/configuration/][Configuration]].

**Note: you need to set =baseURL= right. In my case, the value is in a format
like this ="https://<username>.github.io/<projectName>/"=*

**** Test basic usage
#+BEGIN_SRC shell
$ hugo new post/testing-post.md # Create a new post
#+END_SRC
The new file will locate under =<project>/content/post/=.

**BeautifulHugo specification: to make some functions work, you must use the
words =page= and =post= as the directory.*

Now start the server to check the layout:
#+BEGIN_SRC shell
$ hugo server -D # Start the Hugo server locally
#+END_SRC
Go to http://localhost:1313/ (or http://localhost:1313/projectName/ in my
case) to check the blog. Usually it look wired, so keep modifying =config.toml= until you're happy (Please make your life easy. No need to be perfect).

If everything works fine, you can now start to publish your blog on
the Internet. Let's deploy it on Github pages.

**** Deploy the blog
There're lots of ways of doing it. In my case, I choose to deploy the blog on
project page and use =gh-pages= branch. The official document describes it quite
comprehensively:
- [[https://gohugo.io/hosting-and-deployment/hosting-on-github/][General Description]]
- [[https://gohugo.io/hosting-and-deployment/hosting-on-github/#deployment-of-project-pages-from-your-gh-pages-branch][Specific to my case]] (use =origin= to replace =upstream=)

Must follow the document *carefully*, and you will finally finish setting up
the gh-pages and get a script named =publish_to_ghpages.sh= to automate your
future publishing.

**Notice that in my case, it needs to use =origin= to replace =upstream= in the command
provided in document.* As the master branch of my remote repo is named =origin=.

**** Simple workflow
After it's successfully deployed, go to the github page of this repo, you shall
see 2 branches. =gh-pages= branch is treated as the published site and =master=
branch is your working branch. By doing so, the source files and rendered files
are separated, which helps maintenance and version control.

For the workflow of writing and posting an article to your blog:
1. run =hugo new post/Article-Name.md=
2. write the article
3. run =hugo server -D= and check the final product
4. before publishing, in the article's front matter, set =draft: false=
5. in master branch, commit the new changes
6. run =./publish_to_ghpages.sh= (the shell script you created)

Done.

*** Multi Language Setting
Beautiful Hugo provides some functions to support multi languages, and so does
other themes. Here I introduce my settings:
- English as default
- Simplified Chinese as secondary
- Different main menu for each language
- An option for switching language, placed in main menu, top right corner. (Supported by Beautiful Hugo)
- For each article, an option for switching language, placed under the title. (Supported by Beautiful Hugo)

The files needed to be changed:
- =config.toml=
- =nav.html=
- structure under =content/=
- =single.html=, =terms.html=, =post_preview.html=

**** Modify =config.toml=
Details in official document: [[https://gohugo.io/content-management/multilingual/][Multilingual]]

Here's the excerpt of my =config.toml=, it sets the languages and their main
menu.
#+BEGIN_SRC toml -n 15
DefaultContentLanguage = "en"
DefaultContentLanguageInSubdir = true
[languages]
  [languages.en]
    contentDir = "content/en" #English
    weight = 1
    languageName = "English" # Name shown in the main menu
    subtitle = "This is subtitle for this website"
    [languages.en.params]
      linkedin = "https://muscaestar.github.io/myBlog/en/"
    [[languages.en.menu.main]]
        name = "Blog"
        url = ""
        weight = 1
    [[languages.en.menu.main]]
        name = "About"
        url = "page/about/"
        weight = 3
    [[languages.en.menu.main]]
        name = "Tags"
        url = "tags"
        weight = 3
  [languages.zh-CN]
    contentDir = "content/zh-CN" #Simplified Chinese
    weight = 2
    languageName = "简体中文" # Name shown in the main menu
    subtitle = "副标题"
    [languages.zh-CN.params]
      linkedin = "https://muscaestar.github.io/myBlog/zh-CN/"
    [[languages.zh-CN.menu.main]]
        name = "博客"
        url = ""
        weight = 1
    [[languages.zh-CN.menu.main]]
        name = "关于"
        url = "page/about/"
        weight = 3
    [[languages.zh-CN.menu.main]]
        name = "标签"
        url = "tags"
        weight = 3
#+END_SRC

**** Modify =nav.html=
=nav.html= is a partial template. For more details, go to: [[https://gohugo.io/templates/partials/][Partial Templates]]. Partial template can be placed in
=layouts/partials/= or =themes/<themename>/layouts/partials/=.

=nav.html= is a template provided by Beautiful Hugo, which sets the format of
main menu. It works by default, but in my case, since baseURL is set as
=<username>.github.io/<projectName>=, there's one place need to be changed.

To modify the templates provided by the theme, I recommend to do this:
#+BEGIN_SRC shell
# make a copy of theme's nav.html and place it in your own place
$ cp themes/beautifulhugo/layouts/partials/nav.html layouts/partials/nav.html
#+END_SRC
Then modify the =nav.html= under =layouts/partials/=. Hugo engine will read your
template instead of the theme's. (More details about [[https://gohugo.io/templates/lookup-order/][Hugo's Lookup Order]] )

Here's the excerpt of my =nav.html=. In my case, the baseURL is
=muscaestar.github.io/myBlog/=, so I'll add =/myBlog/= to the original code. See
line 39, 48.
#+BEGIN_SRC html -n 32 :hl_lines 8,17
{{ if .Site.IsMultiLingual }}
    {{ if ge (len .Site.Languages) 3 }}
    <li class="navlinks-container">
        <a class="navlinks-parent">{{ i18n "languageSwitcherLabel" }}</a>
        <div class="navlinks-children">
        {{ range .Site.Languages }}
            {{ if not (eq .Lang $.Site.Language.Lang) }}
            <a href="/myBlog/{{ .Lang }}" lang="{{ .Lang }}">{{ default .Lang .LanguageName }}</a>
            {{ end }}
        {{ end }}
        </div>
    </li>
    {{ else }}
    <li>
        {{ range .Site.Languages }}
        {{ if not (eq .Lang $.Site.Language.Lang) }}
            <a href="/myBlog/{{ .Lang }}" lang="{{ .Lang }}">{{ default .Lang .LanguageName }}</a>
        {{ end }}
        {{ end }}
    </li>
    {{ end }}
{{ end }}
#+END_SRC

**** Modify structure under =content/=
The file structure must match with the =contentDir= variable specified in
=config.toml=. In my case, the structure is set as below:
#+BEGIN_SRC
content/      content/
└── en/       └── zh-CN/
    ├── page/     ├── page/
    └── post/     └── post/
#+END_SRC

**** Modify =single.html=, =terms.html=, =post_preview.html= (Updated)
The problem comes with the variable =.Site.LanguagePrefix=, for some reasons, it
doesn't return complete baseURL. The url of tags will be affected by this problem. The solution is to use =.Site.Language.Lang=.
Here're the details:
#+BEGIN_SRC shell
$ cp themes/beautifulhugo/layouts/_default/single.html layouts/_default/single.html
$ cp themes/beautifulhugo/layouts/_default/terms.html layouts/_default/terms.html
$ cp themes/beautifulhugo/layouts/partials/post_preview.html layouts/partials/post_preview.html
#+END_SRC
Then use =.Site.Language.Lang= to replace =.Site.LanguagePrefix= in the
following files:
- =layouts/_default/single.html=
- =layouts/_default/terms.html=
- =layouts/partials/post_preview.html=

*** In the End
So far, a multi language blog is successfully built. It already has a pretty
easy workflow for blogging, and it's actually enough for daily use.
For explorers, there're still plenty of advanced functionalities of
Hugo, and for me, I'll start working on the integration of Hugo and org-mode in Emacs.

** DONE 用 Hugo 构建一个多语言博客（Github 部署）
CLOSED: [2019-12-27 Sun 17:37]
:PROPERTIES:
:EXPORT_FILE_NAME: MultiLanguage-Blog-Hugo-Github
:EXPORT_HUGO_SECTION: zh-CN/post
:EXPORT_HUGO_LOCALE: zh
:END:
Hugo 是一个非常好用的静态网站生成器，也适合用来创建简单的博客。它有非常多的功能，
并且支持各种 Markdown 语言。本篇文章主要用来记录本博客的创建，主要内容有：
1. 安装和部署
2. 设置多语言
#+hugo: more
*** 为什么用 Hugo？
主要就是快嘛，这也是它在官网和社区中介绍的最大的特点。至于具体究竟多快，其实对我来说并不重要，满足基本的博客要求就行了。
对我来说，在看过各个博客框架后，最终让我选择 Hugo 的原因是，它对 org 的支持。
再详细一点，就是 Hugo 可以和 Emacs 的 org-mode 很好得整合起来。
不过这篇文章不是关于 Emacs 的，因为即使不用 Emacs，Hugo 本身就已经很好用了。
我也是用最通常的使用方法体验了一下 Hugo，太简单方便了，这篇文章就来记录一下这个过程。仅仅需要一点点命令行知识，就可以马上上手 Hugo。
*** 开始之前
请确保已经了解一下三件事项：
1. 最最最基础的 shell 知识
2. 懂得如何查阅官方文档，其实就是愿意耐心读
3. 用过 Github

操作系统： =macOS=

*** 安装和部署
**** 安装
运行下列命令。相关文档: [[https://gohugo.io/getting-started/quick-start/][Quick Start]]
#+BEGIN_SRC shell
$ brew install hugo    # Homebrew
$ hugo version         # Verify, in my case v0.60.1
$ hugo new site <projectName> # Create project directory
$ cd <projectName>     # Go to the new directory
$ git init             # Version control
#+END_SRC
然后把它作为 Github repository。这里不过多赘述。

**** 添加主题
我使用的主题是：[[https://themes.gohugo.io/beautifulhugo/][Beautiful Hugo]]

注意：本篇文章中有个别配置都是适用于 Beautiful Hugo，可能与其他主题有所区别。

安装主题：
#+BEGIN_SRC shell
$ git submodule add https://github.com/halogenica/beautifulhugo.git themes/beautifulhugo
# use theme's example config file as a start point
$ cat themes/beautifulhugo/exampleSite/config.toml >> config.toml
#+END_SRC
在开始配置之前，推荐观察一下 =<project>/themes/beautifulhugo/exampleSite= 目录下的文件，帮助理解整体框架。

随便改改配置文件`config.toml`看看有什么效果。相关文档：[[https://gohugo.io/getting-started/configuration/][Configuration]]

**注意事项： =baseURL= 一定要设置对。本博客的设置是类似于这样的 url 结构
="https://<username>.github.io/<projectName>/"=*

**** 简单测试
#+BEGIN_SRC shell
$ hugo new post/testing-post.md # Create a new post
#+END_SRC
创建的新文档在此目录下 =<project>/content/post/=.

**Beautiful Hugo 的设置：为了部分功能可以使用，必须用特定的路径名，如 =page= 和 =post=**
现在可以开 server 看一看页面的效果：
#+BEGIN_SRC shell
$ hugo server -D # Start the Hugo server locally
#+END_SRC

在浏览器里输入[[http://localhost:1313/][http://localhost:1313/]]查看效果。( 本博客的情况下，链接为 http://localhost:1313/projectName/ ）
第一次的话，应该会看起来比较奇怪，多修改几次=config.toml=文件，直到满意为止。（友情提示：差不多就得了。）

如果这一步完成了，就可以开始部署了。

**** 部署博客
可用的方法有很多，我这里选择的是部署到 project page 上，会用到 =gh-pages= 分支。官方文档写的很详细啦，照着做就可以：
- [[https://gohugo.io/hosting-and-deployment/hosting-on-github/][General Description]]
- [[https://gohugo.io/hosting-and-deployment/hosting-on-github/#deployment-of-project-pages-from-your-gh-pages-branch][Specific to my case]] (use =origin= to replace =upstream=)

一定要一步不漏做下来，不出意外的话，gh-pages 也就设置好了。并且根据指示，你也创
建了一个叫 =publish_to_ghpages.sh= 的脚本，简单说是博文一键发布脚本。

**注意事项：在官方文档指示中，要用 =origin= 字段来替代它使用的 =upstream= 字段。*
主要是因为我的 github repo 的主分支叫 =origin=.

**** 简易发布流程
成功部署之后，在此项目的 github 网页上，你能看到两个分支。
=gh-pages= 分支的内容是最后发布到网页的内容。这样做，你的源文件和发布内容就能分开维护和版本控制，我个人比较喜欢这样的做法。

发布流程：
1. 运行 =hugo new post/Article-Name.md=
2. 编写文章
3. 运行 =hugo server -D= 查看页面效果
4. 发布之前，需要在文章头部的 front matter 做这个修改 =draft: false=
5. commit 主分支的新改动
6. 运行 =./publish_to_ghpages.sh=

完成。

*** 多语言设置
Beautiful Hugo 本身提供了一些支持多语言的功能，我的设置如下：
- 英文作为默认语言
- 中文作为第二语言
- 为不同语言设置各自的主菜单
- 切换网站语言的选项，放置在主菜单中，通常在页面右上角。（Beautiful Hugo 提供）
- 每篇文章的标题下，有一个切换语言的选项。（Beautiful Hugo 提供）

需要修改一下文档：
- =config.toml=
- =nav.html=
- =content/= 路径下的文件结构
- =single.html=, =terms.html=, =post_preview.html=

**** 修改 =config.toml=
相关文档：[[https://gohugo.io/content-management/multilingual/][Multilingual]]

以下为 =config.toml= 的节选：
#+BEGIN_SRC toml -n 15
DefaultContentLanguage = "en"
DefaultContentLanguageInSubdir = true
[languages]
  [languages.en]
    contentDir = "content/en" #English
    weight = 1
    languageName = "English" # Name shown in the main menu
    subtitle = "This is subtitle for this website"
    [languages.en.params]
      linkedin = "https://muscaestar.github.io/myBlog/en/"
    [[languages.en.menu.main]]
        name = "Blog"
        url = ""
        weight = 1
    [[languages.en.menu.main]]
        name = "About"
        url = "page/about/"
        weight = 3
    [[languages.en.menu.main]]
        name = "Tags"
        url = "tags"
        weight = 3
  [languages.zh-CN]
    contentDir = "content/zh-CN" #Simplified Chinese
    weight = 2
    languageName = "简体中文" # Name shown in the main menu
    subtitle = "副标题"
    [languages.zh-CN.params]
      linkedin = "https://muscaestar.github.io/myBlog/zh-CN/"
    [[languages.zh-CN.menu.main]]
        name = "博客"
        url = ""
        weight = 1
    [[languages.zh-CN.menu.main]]
        name = "关于"
        url = "page/about/"
        weight = 3
    [[languages.zh-CN.menu.main]]
        name = "标签"
        url = "tags"
        weight = 3
#+END_SRC

**** 修改 =nav.html=
=nav.html= 是一个 partial template. 相关文档：[[https://gohugo.io/templates/partials/][Partial Templates]]. Partial
template 可以被放在 =layouts/partials/= 或者 =themes/<themename>/layouts/partials/=.

=nav.html= 由 Beautiful Hugo 提供, 用来构建主菜单，默认即可使用。但是本博客的 baseURL 被设置为 =<username>.github.io/<projectName>=, 所以有个地方是需要改动的。

推荐在改动前做以下操作：
#+BEGIN_SRC shell
# make a copy of theme's nav.html and place it in your own place
$ cp themes/beautifulhugo/layouts/partials/nav.html layouts/partials/nav.html
#+END_SRC
需要修改的`nav.html`是放在`layouts/partials/`路径下的. Hugo 会将你的个人设置优先于主题的设置。([[https://gohugo.io/templates/lookup-order/][Hugo's Lookup Order]])

以下是 =nav.html= 的节选. 因为我的 baseURL 值为 =muscaestar.github.io/myBlog/=, 所
以我把 =/myBlog/= 加到特定的地方，详情见行 39,48.
#+BEGIN_SRC html -n 32 :hl_lines 8,17
{{ if .Site.IsMultiLingual }}
    {{ if ge (len .Site.Languages) 3 }}
    <li class="navlinks-container">
        <a class="navlinks-parent">{{ i18n "languageSwitcherLabel" }}</a>
        <div class="navlinks-children">
        {{ range .Site.Languages }}
            {{ if not (eq .Lang $.Site.Language.Lang) }}
            <a href="/myBlog/{{ .Lang }}" lang="{{ .Lang }}">{{ default .Lang .LanguageName }}</a>
            {{ end }}
        {{ end }}
        </div>
    </li>
    {{ else }}
    <li>
        {{ range .Site.Languages }}
        {{ if not (eq .Lang $.Site.Language.Lang) }}
            <a href="/myBlog/{{ .Lang }}" lang="{{ .Lang }}">{{ default .Lang .LanguageName }}</a>
        {{ end }}
        {{ end }}
    </li>
    {{ end }}
{{ end }}
#+END_SRC

**** 修改路径 =content/= 下的文件结构
路径名必须与配置文件 =config.toml= 中的 =contentDir= 值相匹配。本博客的结构如下：
#+BEGIN_SRC
content/      content/
└── en/       └── zh-CN/
    ├── page/     ├── page/
    └── post/     └── post/
#+END_SRC

**** 修改 =single.html=, =terms.html=, =post_preview.html= (更新)
变量 =.Site.LanguagePrefix= 有一些问题，没法返回完整的 url，于是我用
=.Site.Language.Lang= 来代替它。
#+BEGIN_SRC shell
$ cp themes/beautifulhugo/layouts/_default/single.html layouts/_default/single.html
$ cp themes/beautifulhugo/layouts/_default/terms.html layouts/_default/terms.html
$ cp themes/beautifulhugo/layouts/partials/post_preview.html layouts/partials/post_preview.html
#+END_SRC
在下列三个文件中，用 =.Site.Language.Lang= 来代替 =.Site.LanguagePrefix=:
- =layouts/_default/single.html=
- =layouts/_default/terms.html=
- =layouts/partials/post_preview.html=

*** 写在最后
至此，一个多语言博客就设置部署完成了。文中提到的发布流程也足够日常发布博文使用，
如果没什么特别要求，一个简单的博客就建成了。当然 Hugo 还有很多高级功能可以使用，
这里就不多介绍，看官方文档就可以。接下来计划介绍如何整合 Hugo 和 org-mode，让 org-mode 写博客的体验更加丝滑。
* DONE Use Emacs to Organize Hugo Blog / 用 Emacs 来管理 Hugo 博客 :blog:Hugo:Emacs:org_mode:
CLOSED: [2019-12-29 Sun 20:52]
** DONE Use Emacs to Organize Hugo Blog
CLOSED: [2019-12-29 Sun 17:51]
:PROPERTIES:
:EXPORT_FILE_NAME: Emacs-ox-hugo-Organize-Blog
:EXPORT_HUGO_SECTION: en/post
:END:
Emacs is a magical 'software' and you can do 'everything' in it, of course writing
and organizing your blog posts. Last post, I built this blog with vanilla Hugo. This article will introduce org-mode and ox-hugo to
make Hugo better for Emacs users.
#+hugo: more
*** Why Emacs? Org-mode?
Almost every programmer have at least heard the famous 'GNU/Emacs', or the joke about the
Editor War between Vim users and Emacs users. Both of them seem to be very proud of
mastering at least one of these 'highly customizable' 'tough-learning' 'COOL' text
editor. Don't get me wrong. Vim and Emacs are great, and I enjoy using both of
them. But to be honest, with the rise of modern IDEs and their 'not bad'
plugins, those actual Vim users and Emacs user are gradually becoming the minority group.
Admit it, out-of-the-box is the new black.

So, why am I bother writing this article introducing a tiny customization
package in Emacs?
Because even though I'm kinda happy with this OOTB world, I still realize that
nobody really feels satisfied with it. Yes, modern software is so convenient.
But the interesting thing is, for example, WHY there's no alternatives for
org-mode?

Finally, here comes the hero, the Org-mode. I think org-mode is the reason
that I insist on sticking with Emacs. My schedules, projects, todos, study notes with plenty of
runnable codes, sudden crazy ideas... so much programming-related or not related
stuffs are well organized with it. It becomes my second brain. It *organizes* my life.
So cliché, but so true.

So I write this article. It's an introduction of some tiny features of the
tremendous Emacs. It's my 'love letter' to the lovely org-mode. I wish I could meet you
earlier. You literally change my life.

OK, that's enough. Let's jump back to the topic.
*** Why ox-hugo?
First of all, checkout the official recommendation of [[https://gohugo.io/tools/editors/][Hugo's editor plugins]]. Yes,
there're many other plugins, in Vim, VS Code, Atom, Sublime... If you don't feel
anything with
org-mode, its time to leave. I believe other plugins should work fine
and 'more OOTB'.

For Emacs user, there're two packages, [[https://github.com/masasam/emacs-easy-hugo][easy-hugo]] or [[https://ox-hugo.scripter.co/][ox-hugo]]. Here's what I
thought. Easy-hugo is made for Emacs, and ox-hugo is made specifically for
org-mode. Easy-hugo helps you dealing with blog-related file management and configurations,
using some shortcuts to replace redundant CLI works. While, ox-hugo goes a different
direction, which is basically an org-mode exporter. It is the details of
ox-hugo's features design that impressed me. In my opinion, ox-hugo's design match some of the true
philosophies of org-mode.

"Using Org just as a markup like Markdown is a miniscule part of its complete
feature-set." -- [[https://ox-hugo.scripter.co/doc/why-ox-hugo/][Why ox-hugo?]]
*** It is MORE about your thinking than doing
**** Design your own structure
When it comes to customization, there's no simple HOW TO.
Ox-hugo is well documented in its [[https://ox-hugo.scripter.co/][website]]. It offers you lots of functions, and
sometimes people may become confused about their combination.
If you are familiar with self-configuration, you don't need my saying.
If you are not, maybe you can ask yourself these questions:
- Am I satisfied with my current workflow? How about in the nearly future?
- Do I need to use all the functions it offers?
- Which functions are my actual needs?
- Can I improve my workflow without installing this package?
- (configuration time) < (time saved for the future) Really?

It is worthy to dig your mind, and finally find your true desire. Otherwise,
you just jumped into an infinite editor customization loop.
**** Here's my thinking
My reason for using it:
- I'm used to taking notes in org-mode, I wish I could just copy my notes as
  some parts of my posts without any changes in the format.
- My blog will be maintained in two languages, which means for each post,
  there're 2 files with same file name while placing in different directories.
  To keep them linked, everytime I change one, I should make sure the other is
  also changed. The two files are actually one post, so I wish I could manage
  them together.
- I write blog in Chinese, but with Emacs' auto word-wrap mode, each line
  creates an unnecessary space when finally rendered to html file. It needs to
  be fixed.
- If I could organize all my post in just one org file. So that I could easily
  do tags, modified time, and so on.
- If the only one org file becomes too big, I could create another, and it won't
  affect any previous structures.
- How about move to another dynamic blog framework, so many automation problems will
  be solved. But can I use evil-mode? org-mode? It may produce more
  configuration time.
- I already got lots of notes written in org mode, and I'm planning to make them my
  future posts. So with ox-hugo, it will definitely save my time.
*** Demo of mine
**** The only one org file
On the top of the org file, I put these declarations at the head as global settings.
#+BEGIN_SRC org
 #+HUGO_FRONT_MATTER_FORMAT: yaml
 #+HUGO_BASE_DIR: ~/myBlog/
 #+HUGO_AUTO_SET_LASTMOD: t
#+END_SRC
**** Use YASnippet to create blank template
[[https://joaotavora.github.io/yasnippet/snippet-development.html][Documentation]] of write your own YASnippet template.

Everytime I want to create a new post, I can just type
=<post= and then hit =TAB=.

Here's my YASnippet template setting.
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: hugo-new-post
# key: <post
# expand-env: ((yas-indent-line 'fixed) (yas-wrap-around-region 'nil))
# --

 * ${1:Post title} / ${2:博文标题}
 ** TODO $1
 :PROPERTIES:
 :EXPORT_FILE_NAME: ${3:File-name}
 :EXPORT_HUGO_SECTION: en/post
 :END:
 Abstract
 #+hugo: more
 *** Heading 1
 text

 ** TODO $2
 :PROPERTIES:
 :EXPORT_FILE_NAME: $3
 :EXPORT_HUGO_SECTION: zh-CN/post
 :EXPORT_HUGO_LOCALE: zh
 :END:
 前言
 #+hugo: more
 *** 正文标题 1
 正文
#+END_SRC
*** In the End
This article is not about HOW TO, because I believe it is meaningless to write
'do-what-I-say' article in terms of customization with Emacs. My configuration
only works in my case, what matters is the process of reaching it.
** DONE 用 Emacs 来管理 Hugo 博客
CLOSED: [2019-12-29 Sun 20:51]
:PROPERTIES:
:EXPORT_FILE_NAME: Emacs-ox-hugo-Organize-Blog
:EXPORT_HUGO_SECTION: zh-CN/post
:EXPORT_HUGO_LOCALE: zh
:END:
Emacs 是个“神奇”的软件，你可以用它做“任何事”，当然这也就包括了写博客和管理博文。上一
篇博文中，我讲了如何使用最基础的 Hugo 框架来写博客。今天这篇就来介绍一下，我是如何
使用 org-mode 和 ox-hugo，来让 Hugo 博客体验更丝滑。
#+hugo: more
*** 为什么使用 Emacs？Org-mode?
我想大部分程序员应该都听过 GNU/Emacs 的名声，或者至少听说过 Vim 和 Emacs 的宇宙最
强编辑器大战，这种老梗。很多 Vim 或者 Emacs 的使用者，或者说，初学者，都挺喜欢津津乐
道这种“上古编辑器”的自定义啊，学习门槛高啊，什么不需要使用鼠标的高效啊，装逼性
强啊之类的优点。不是说不好，我也挺喜欢的，不过说实话，稍微走出“上古编辑器”这个圈
地自萌的领域，就会发现，其实真的愿意使用 Vim 或 Emacs 的人，真的越来越少了。主要一个
原因，现代 IDE 越来越好用了，并且大都自带 Vim, Emacs 插件。键位对上了，而且开箱即用，
不得不说，用一下真的很香。

既然这么香，那我何必在这里写一个配置 Emacs 的文章？还只是一个微不足道的小功能？我
承认，我也很喜欢开箱即用，节省了很多时间和麻烦。但是但是，开箱即用，永远都不可能
完全贴合每一个使用者的习惯。所谓编辑器，要不是你适应它，就得它适应你，最后还是
时间花费上的权衡。说现代软件越来越先进，其实也不全对，比如 org-mode 的存在，就
让我一直费解：10 多年了，为什么没有人能做出一个超越 org-mode 的，集项目管理，时间规划，
Markup 格式，还能内置跑代码等，各种功能于一身的软件？

Org-mode 就是我一直使用 Emacs 的原因，至今没有找到任何一个替代品。它的功能实在太
强大，各部分之间的集成又实在是太顺滑。我曾经沉迷尝试各种效率软件，但没有一个能像
org-mode 一样真的 *改变* 我的生活和习惯。我想应该有许多 Emacs 使用者，也是如此深深喜爱
着 org-mode。

大概，这篇文章应该就是只为 org-mode 而写，为 org-mode 爱好者而写。

*** 为什么使用 ox-hugo?
开始之前，何不看看这个：[[https://gohugo.io/tools/editors/][Hugo的编辑器插件]]. Hugo 其实支持了很多的编辑器, Vim, VS
Code, Atom, Sublime 等等。所以要不是真的 org-mode 爱好者，只要选择自己合适的插
件就足够了。工具只是工具，适合自己的才是最好的。

在 Emacs 上，Hugo 有两款插件，[[https://github.com/masasam/emacs-easy-hugo][easy-hugo]] 和 [[https://ox-hugo.scripter.co/][ox-hugo]]. 这两款插件的定位是不一样的，
easy-hugo 是一款在 Emacs major-mode 上使用的博客内容管理工具，主要功能是通过一些快
捷操作来实现原来需要在命令行上的重复操作。ox-hugo 从最最基本的功能上来说，就是一
款 org 格式转 Markdown 格式的工具，听起来很普通的样子，但是它对功能的设计十分惊艳，
完美地和 org-mode 的优点契合在一起。这也是我在使用之后，才发觉的。

Org-mode 决不仅仅是一个 markup 语言，这只是它表面的皮毛罢了。你可以看看 ox-hugo 的开
发者的观点：[[https://ox-hugo.scripter.co/doc/why-ox-hugo/][Why ox-hugo?]]
*** 所思比所做更值得注意
**** 想想究竟什么才适合你
对于自定义，从来就没有什么简单明了的“该怎么做”。
[[https://ox-hugo.scripter.co/][官方文档]]里对所有功能都有详细的介绍。对于达成一个特定的功能，ox-hugo 里是有很多选
择的，这也就会造成一些特殊的困扰：究竟应该如何组合各个不同的功能。相信每个玩自定义
的朋友在刚开始都会有类似麻烦。在做出选择之前，我通常会考虑一下几个问题：
- 我对目前的操作流程满意吗？满意程度在将来会改变吗？
- 我需要使用它的全部功能吗？
- 哪几个功能是我真的需要的？
- 在安装它之前，我能够通过其他地方的改进，来改善目前的操作流程吗？
- 配置所需时间真的小于将来节省下来的时间吗？

多多思考一下自定义功能的价值，还是很有用处的，有些时候需要适可而止。否则总有一天，
你会感叹自己把大把的时间都浪费在了没有实际意义的配置上。
**** 一些我的理由
分享一下我决定使用 ox-hugo 的理由：
- 我已经习惯于使用 org-mode 记笔记，我希望我可以把笔记内容直接复制粘贴作为博文的内
  容，而不需要改变格式。
- 我的博客是中英双语，同时维护一篇博文的两个语言版本，意味着我得在两个不同的路径
  下管理两个文件。为了确保 Hugo 将两份文件视作同一博文的两个版本，很多时候我必须同
  时修改两个文件的内容，以避免冲突。假如我可以在一个文件中管理多个文本，效率会有
  很大的提升。
- 当我用中文在 Emacs 里写作时，通常开着 word-warp mode，也就是自动换行。这会导致一
  个问题，就是当 Hugo 在将文档转为 html 文件时，每个自动换行的点都会多出一个空格，十
  分影响美观。ox-hugo 能够自动处理这个问题。
- 假如我的所有博文都能放在同一个文件中，我就能很方便地统一管理 tag 以及其他设定了。
- 假如我的 org 文件过大，我也可以再新建新的 org 文件，并且不会影响之前的任何已发布的
  设置。
- 似乎迁移去更产品化的博客系统也能解决我存在的这些问题，可是我就不一定能很好地使用
  org-mode 和 evil-mode 键位。可能会出现许多新的麻烦。
- 我已经有了许多 org-mode 下的笔记，我也计划将它们作为博文内容发布。因此，配置
  ox-hugo 一定能在将来这方面节省下我的时间。
*** 我的配置
**** 集合所有博文的 org 文件
所有的博文都放在这份文件中，我只要在文件开头写上这些，就是全局设定。
#+BEGIN_SRC org
 #+HUGO_FRONT_MATTER_FORMAT: yaml
 #+HUGO_BASE_DIR: ~/myBlog/
 #+HUGO_AUTO_SET_LASTMOD: t
#+END_SRC
**** 使用 YASnippet 制作模板
[[https://joaotavora.github.io/yasnippet/snippet-development.html][Documentation]] of write your own YASnippet template.

Everytime I want to create a new post, I can just type
=<post= and then hit =TAB=.

Here's my YASnippet template setting.
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: hugo-new-post
# key: <post
# expand-env: ((yas-indent-line 'fixed) (yas-wrap-around-region 'nil))
# --

 * ${1:Post title} / ${2:博文标题}
 ** TODO $1
 :PROPERTIES:
 :EXPORT_FILE_NAME: ${3:File-name}
 :EXPORT_HUGO_SECTION: en/post
 :END:
 Abstract
 #+hugo: more
 *** Heading 1
 text

 ** TODO $2
 :PROPERTIES:
 :EXPORT_FILE_NAME: $3
 :EXPORT_HUGO_SECTION: zh-CN/post
 :EXPORT_HUGO_LOCALE: zh
 :END:
 前言
 #+hugo: more
 *** 正文标题 1
 正文
#+END_SRC
*** 写在最后
这篇博文并没有涉及如何使用，我觉得官网文档已经描述的很清楚了，同时我也觉得，对于
Emacs 上的自定义，写下我自己的配置用处也不是很大，因为这终究只是适合我个人的配置。
我想，真的重要的，是在过程中的个人思考吧。
* DOING Musca's Algo Notes: Preview / Musca 的算法笔记：总起 :Algorithm:
** DONE Musca's Algo Notes: Preview
CLOSED: [2020-02-13 Thu 20:56]
:PROPERTIES:
:EXPORT_FILE_NAME: Musca-Algo-Notes-Preview
:EXPORT_HUGO_SECTION: en/post
:END:
Algorithms, the field which is so fundamental, so important, and so hard,
relatively speaking. For a student without any working experience, algorithm should
be:
1. A proof of your solid knowledge base
2. A guide to help you truly understand some classic source code
3. An inspirer, connecting the tech world with reality
I'll keep updating this post, listing key terms in Algorithm field. The list can
also be regarded as my study path. I'll try to write blogs for every term mentioned.
#+hugo: more
*** Basic Terminology
- Asymptotic complexity analysis - 渐进式复杂度分析
  - Big O notation(asymptotic notation) - 大 O 符号（渐进符号）
- Recursion - 递归
- Sorting - 排序
- Searching - 搜索
- Set - 集合
- Tree - 树
- Graph - 图
- Greedy - 贪心
- Divide and conquer - 分治
- Backtracking algorithm - 回溯
- Dynamic programming - 动态规划
- BitMap - 位图
*** Data Structure
- Array - 数组
- List - 列表
- Linked list - 链表
  - Singly linked list - 单链表
  - Doubly linked list - 双向链表
  - Circular linked list - 循环链表
- Stack - 栈
- Queue - 队列
  - Array-implementation queue - 顺序队列
  - Linked-list implementation queue - 链式队列
  - Double-ended queue - 双端队列
  - Circular buffer(circular queue) - 循环队列
  - Blocking queue - 阻塞队列
  - Concurrent queue - 并发队列
- Priority queue - 优先队列
  - Double-ended priority queue - 双端优先队列
- Hash table - 散列表、哈希表
- Binary tree - 二叉树
  - BST(Binary search tree) - 二叉查找树
  - Self-balancing (or height-balanced) binary search tree - 平衡二叉查找树
  - Red-black tree - 红黑树
  - AVL Tree - AVL 树
- Recursion Tree - 递归树
- Heap - 堆
- B+ Tree - B＋树
- Skip list - 跳表
*** Algorithm
**** Sorting algorithms - 排序算法
- Bubble sort - 冒泡排序
- Insertion sort - 插入排序
- Shell sort - 希尔排序
- Selection sort - 选择排序
- Merge sort - 归并排序
- Quick sort(partition-exchange sort) - 快速排序
- Bucket sort - 桶排序
- Counting sort - 计数排序
- Radix sort - 基数排序
- Heap sort - 堆排序
- Topological sort - 拓扑排序
**** String-matching algorithms - 字符串匹配算法
- Brute Force - 暴力匹配算法、BF 算法
- Rabin-Karp Algorithm - RK（Rabi Karp) 算法
- Boyer-Moore Algorithm - BM（Boye Moore）算法
- KMP(Knuth–Morris–Pratt) Algorithm - KMP 算法
- Trie Tree - Trie 树、字典树
- Aho–Corasick Algorithm - AC 自动机算法
**** Searching - 搜索
- Binary search - 二分查找
- DFS(Depth-First search) - 深度优先搜索
- BFS(Breadth-first search) - 广度优先搜索
- Dijkstra Algorithm - Dijkstra 算法
- A* search algorithm - A*算法
**** Hash algorithms - 哈希算法、散列算法
*** The End
Implementation code: [[https://github.com/muscaestar/algo][Github Repo]]
*** Reference
- [[https://time.geekbang.org/column/intro/126][极客时间－数据结构与算法之美]]
- [[https://www.khanacademy.org/computing/computer-science/algorithms][Cormen and Balkcom's Algorithms course]]
- Wikipedia

** DONE Musca 的算法笔记：总起
CLOSED: [2020-02-13 Thu 20:59]
:PROPERTIES:
:EXPORT_FILE_NAME: Musca-Algo-Notes-Preview
:EXPORT_HUGO_SECTION: zh-CN/post
:EXPORT_HUGO_LOCALE: zh
:END:
算法算法算法，在计算机行业，大概过了这关才能算真的入了门。初入社会的学生，
特别是半道转行的，比如在下，更应该知道算法的重要性并主动学习。学习算法至少有下列好处：
1. 证明自己的基础知识（不仅仅只会跟着框架“敲”代码）
2. 帮助自己更深入理解优秀的源代码
3. 启发思考，从另一个角度观察技术对世界的改变
这篇博文记录了算法话题中常见的技术关键词。我会不断更新它，并且以此为学习路径，写
新的笔记。
#+hugo: more
*** 基本术语概念
- 渐进式复杂度分析 - Asymptotic complexity analysis
  - 大 O 符号（渐进符号） - Big O notation(asymptotic notation)
- 递归 - Recursion
- 排序 - Sorting
- 搜索 - Searching
- 集合 - Set
- 树 - Tree
- 图 - Graph
- 贪心 - Greedy
- 分治 - Divide and conquer
- 回溯 - Backtracking algorithm
- 动态规划 - Dynamic programming
- 位图 - BitMap

*** 数据结构
- 数组 - Array
- 列表 - List
- 链表 - Linked list
  - 单链表 - Singly linked list
  - 双向链表 - Doubly linked list
  - 循环链表 - Circular linked list
- 栈 - Stack
- 队列 - Queue
  - 顺序队列 - Array-implementation queue
  - 链式队列 - Linked-list implementation queue
  - 双端队列 - Double-ended queue
  - 循环队列 - Circular buffer(circular queue)
  - 阻塞队列 - Blocking queue
  - 并发队列 - Concurrent queue
- 优先队列 - Priority queue
  - 双端优先队列 - Double-ended priority queue
- 散列表、哈希表 - Hash table
- 二叉树 - Binary tree
  - 二叉查找树 - BST(Binary search tree)
  - 平衡二叉查找树 - Self-balancing (or height-balanced) binary search tree
  - 红黑树 - Red-black tree
  - AVL 树 - AVL Tree
- 递归树 - Recursion Tree
- 堆 - Heap
- B＋树 - B+ Tree
- 跳表 - Skip list

*** 算法
**** 排序算法 - Sorting algorithms
- 冒泡排序 - Bubble sort
- 插入排序 - Insertion sort
- 希尔排序 - Shell sort
- 选择排序 - Selection sort
- 归并排序 - Merge sort
- 快速排序 - Quick sort(partition-exchange sort)
- 桶排序 - Bucket sort
- 计数排序 - Counting sort
- 基数排序 - Radix sort
- 堆排序 - Heap sort
- 拓扑排序 - Topological sort
**** 字符串匹配算法 - String-matching algorithms
- 暴力匹配算法、BF 算法 - Brute Force
- RK（Rabin-Karp) 算法 - Rabin-Karp Algorithm
- BM（Boyer-Moore）算法 - Boyer-Moore Algorithm
- KMP 算法 - KMP(Knuth–Morris–Pratt) Algorithm
- Trie 树、字典树 - Trie Tree
- AC 自动机算法 - Aho–Corasick Algorithm
**** 搜索 - Searching
- 二分查找 - Binary search
- 深度优先搜索 - DFS(Depth-First search)
- 广度优先搜索 - BFS(Breadth-first search)
- Dijkstra 算法 - Dijkstra Algorithm
- A*算法 - A* search algorithm
**** 哈希算法、散列算法 - Hash algorithms

*** 写在最后
代码实现：[[https://github.com/muscaestar/algo][Github Repo]]

*** 参考资料
- [[https://time.geekbang.org/column/intro/126][极客时间－数据结构与算法之美]]
- [[https://www.khanacademy.org/computing/computer-science/algorithms][Cormen and Balkcom's Algorithms course]]
- Wikipedia
* DONE Algo Day 1: Start with Binary Tree / 算法 Day 1: 二叉树初入门 :Algorithm:
CLOSED: [2020-02-17 Mon 03:16]
** DONE Algo Day 1: Start with Binary Tree
CLOSED: [2020-02-17 Mon 03:15]
:PROPERTIES:
:EXPORT_FILE_NAME: Musca-Algo-Notes-Day-1
:EXPORT_HUGO_SECTION: en/post
:END:
Just start from the interesting one. I don't really want to go back and start
from array, linked list and so on... My past experience tells me if I try to be
perfect in my safe zone first, then I may never get to the next level.

Binary Tree is a good spot to start from. You can really learn recursion with
it. You do lots of abstract thinking even if you know it just shapes like a tree.
Some of its variants are very important in current industry, like Red-black Tree
and B+ Tree. This post aims to cover only the beginner level, so I'll leave
those advanced structures for other posts.

This post mainly includes:
1. Implementation of Binary Tree and BST
2. Operations like traverse, insert, delete and find

#+hugo: more
*** Basic Terminology
**** Tree (From [[https://en.wikipedia.org/wiki/Tree_(data_structure)][WIKIPEDIA]])
- A tree is a widely used abstract data type (ADT) that simulates a hierarchical
  tree structure, represented as a set of linked nodes.
- Recursively defining, a tree is a collection of nodes, where each node
  consists of a list of references of other nodes.
- Constraints: no reference is duplicated, and none points to the root.
***** Terminology used in trees
- *Node*: A basic unit of data structure.
- *Root*: The top node in a tree, the prime ancestor.
- *Internal node*: A node with at least one child.
- *Leaf*: A node with no children.
- *Edge*: The connection between one node and another.
- *Depth*: The number of edges on the shortest path between a node and the root.
  (Root's depth is 0.)
- *Height*: The number of edges on the longest path between a node and a
  descendant leaf. (Root is the highest.)
- *Level*: Depth + 1.(Root's level is 1.)
- [[https://en.wikipedia.org/wiki/Tree_(data_structure)#Terminology_used_in_trees][More in Wiki]]

**** Binary Tree (From [[https://en.wikipedia.org/wiki/Binary_tree][WIKIPEDIA]])
- A binary tree is a tree data structure in which each node
  has at most two children, left child and right child.
- A recursive definition: a (non-empty) binary tree is a tuple (L, S, R), where L and R are binary trees
  or the empty set and S is a singleton set.

**** Binary Search Tree (BST)
- A binary tree, each key of whose nodes must be greater than any
  key stored in the left sub-tree, and less than any key stored in
  the right sub-tree.
- It allows fast lookup, addition and removal of items.

*** Implementation of a Binary Tree
Generally, You can implement a binary tree with an array or a linked list. The
most common and easy way is using linked list, which is more obvious to the
definition. Further, a BST is also commonly implemented with linked list and
recursion. As for array, it is used with Heap(a special complete binary tree).

Here's a simple implementation of a binary tree, which has a nested class =Node=.
Each node has two references pointing to other nodes, and a property
holding the element. For the class =BinaryTree=, it only holds one node, which is
the root node.
#+BEGIN_SRC java
public class BinaryTree<E> {
    //only one property
    private Node<E> root;

    //nested Node class
    static class Node<E> {
        E element;
        Node<E> leftNode;
        Node<E> rightNode;
        //constructor, getter, setter
    }

    //more...
}
#+END_SRC
*** Binary Tree Traversals ([[https://en.wikipedia.org/wiki/Tree_traversal][From WIKIPEDIA]])
**** Types of tree traversals
1. Pre-order traversal (DFS)
2. In-order traversal (DFS)
3. Post-order traversal (DFS)
4. Level-order traversal (BFS)

**** Taste of recursive traversal
Using DFS to traverse a binary tree is the most common way, and it can be
easily done with recursion. But for BFS, the level-order traversal is a bit more
complex than the former three. Since the DFS/BFS is a core concept in Graph,
this post focuses more on the three common traversals, pre-order, in-order, and
post-order.

Each of these three traversals can be implemented in both recursion way and
iterative way. By comparing the two implementations, you can see the
recursion is such a beauty. [[https://en.wikipedia.org/wiki/Tree_traversal#Implementations][Checkout the pseudocode.]]

Basically, these traversals are the combination of following operations in
various order (N stands for the current node):
- (L) Recursively traverse N's left subtree. This step is finished at the node N again.
- (R) Recursively traverse N's right subtree. This step is finished at the node N again.
- (N) Process N itself.

According to this, the traversals can also be represented as:
- Pre-order = NLR
- In-order = LNR
- Post-order = LRN

One thing to notify, for these 3 types of traversals, even though the order of
"print each node itself" is different, the order of "stack-in-out of each node's
recursive method" is the same.

For wholly understand the traversals, highly recommend you drawing pictures by
yourself. Remember to record the order of:
- when is each recursive method pushed into call stack
- when is each recursive method popped out of call stack
- when is each node itself printed
 
***** NLR: pre-order traversal
#+BEGIN_SRC java
public void preOrder(Node<E> N) {
    if (N == null) {
        return;
    }
    doSomething(N); // N
    preOrder(N.leftNode); // L
    preOrder(N.rightNode); // R
}
#+END_SRC

***** LNR: in-order traversal
#+BEGIN_SRC java
public void inOrder(Node<E> N) {
    if (N == null) {
        return;
    }
    inOrder(N.leftNode); // L
    doSomething(N); // N
    inOrder(N.rightNode); // R
}
#+END_SRC
***** LRN: post-order traversal
#+BEGIN_SRC java
public void postOrder(Node<E> N) {
    if (N == null) {
        return;
    }
    postOrder(N.leftNode); // L
    postOrder(N.rightNode); // R
    doSomething(N); // N
}
#+END_SRC
*** BST with basic operations
Binary Search Tree is a binary tree, so it extends the Binary Tree's structure.
With an in-order traversal, you can get a sorted list of nodes. Since the nodes
of BST are structured according to their keys(values), methods of insertion, lookup, and
deletion should be carefully defined.
**** Define a BST
A basic structure of BST. Note that element of node should implement
=Comparable=, as one of the usages of BST is to sort.
#+BEGIN_SRC java
public class BinarySearchTree<E extends Comparable<? super E>>() {

    // same as Binary Tree
    private Node<E> root;

    // same as Binary Tree
    static class Node<E>() {
        E element;
        Node<E> leftNode;
        Node<E> rightNode;
        // getters, setters, constructors
    }

    public void printSortedEle() {/* in-order traversal */}

    public Node<E> insert(E x) {...}
    public Node<E> find(E x) {...}
    public Node<E> delete(E x) {...}

    public Node<E> findMin() {...}
    public Node<E> findMax() {...}

    /*other methods*/
}

#+END_SRC
**** Insertion: recursive way
A way of using recursion is to utilize the method overloading. The logic is
simple:
- *Recursive step*:
  1. If =x= is less than =root.element=, do this with the left subtrees.
     Otherwise, the right subtrees. Then re-set the root of the subtree with the
     coming back value.
  2. If =x= equals to =root.element=, do nothing.
  3. Finally, return root.
- *Base case*:
  1. =root= is null, then return a new Node with =x= (it becomes the new root).
    
#+BEGIN_SRC java
public Node<E> insert(E x) {
    return insert(x, root);
}

public Node<E> insert(E x, Node<E> root) {
    /* validate argument */

    if (root == null) {
        return new Node<>(x);
    }

    int cmp = x.compareTo(root.element);
    if (cmp < 0) {
        root.leftNode = insert(x, root.leftNode);
    } else if (cmp > 0) {
        root.rightNode = insert(x, root.rightNode);
    } else { /* cmp == 0, do nothing */ }

    return root;
}


#+END_SRC
**** Lookup: recursive way
The basic logic is simple:
- *Recursive step*:
  1. If =x= is less than =root.element=, do this with the left subtrees.
     Otherwise, the right subtrees. Then return the coming back value.
- *Base cases*:
  1. =x= equals to =root.element=, then return the root (which is the node wanted).
  2. =root= is null, then return null (the node wanted not exists).

#+BEGIN_SRC java
public Node<E> find(E x) {
    return find(x, root);
}

public Node<E> find(E x, Node<E> root) {
    /* validate agrument */

    if (root == null) {
        return null;
    }
    int cmp = x.compareTo(root.element);
    if (cmp < 0) {
        return find(x, root.leftNode);
    } else if (cmp > 0) {
        return find(x, root.rightNode);
    } else { // cmp == 0
        return root;
    }
}
#+END_SRC
**** Deletion: recursive way
Like many data structures, the deletion is kinda tricky. There're three
circumstances needed to be considered. Here's the logic:
- *Recursive step*:
  1. If =x= is less than =root.element=, do this with the left subtree.
     Otherwise, the right subtrees. Then re-set the root of the subtree with
     the coming back value.
  2. If =x= equals to =root.element=, then check root's children:
     1. If root has /two children/, find the successor of the root first. Replace
        root's element with successor's. Then delete successor, and re-set the
        root of right subtree with the coming back value. (So, the 'root node' is
        actually not changed. What is replaced is the root's element. And the
        'successor node' is truely deleted.)
     2. Base case 1.
     3. Base case 2.
  3. Finally, return root.
- *Base cases*:
  1. If root has /one child/, make the child be the new root. Then return the new root.
  2. If root has /no child/, then make the root be null (delete it). Then return the root(null).
  3. If root is null, then return null. (In this case, node is not found, so no node is deleted.)

#+BEGIN_SRC java
public Node<E> delete(E x) {
    root = delete(x, root);
    return root;
}

public Node<E> delete(E x, Node<E> root) {
    /* validate argument */

    if (root == null) {
        return null;
    }
    int cmp = x.compareTo(root.element);
    if (cmp < 0) {
        root.leftNode = delete(x, root.leftNode);
    } else if (cmp > 0) {
        root.rightNode = delete(x, root.rightNode);
    } else { // cmp == 0, so going to delete root

        if (root.leftNode != null && root.rightNode != null) { // two children
            // pick root's successor, replace root's element with successor's,
            // then delete successor
            // otherwise, picking root's predecessor also work

            // find the minimal node's element of right subtree
            E newEleOfRoot = findMin(root.rightNode).element;
            root.element = newEleOfRoot;
            root.rightNode = delete(newEleOfRoot, root.rightNode);

        } else if (root.leftNode != null || root.rightNode != null) {
            // one child, just use it to replace root
            root = (root.leftNode != null) ? root.leftNode : root.rightNode;

        } else { // no child, just delete root
            root = null;
        }
    }
    return root;
}
#+END_SRC
**** Summary of basic operations
- When one recursive method cannot fit in the normal use case, utilize method
  overloading, creating a non-recursive method (with fewer parameters) to assist
  it. The non-recursive method is exposed for oursiders to use, while the recursive
  method is called in the non-recursive one.
- =insert(E x)= and =delete(E x)= doesn't have to return any value. Because what
  they eventually return, is the root of the BST. I choose to return
  the root, just personal choice. Doesn't really matter.
- In deletion operation, when the node to be deleted has two children, my
  implementation pick successor. Actually choose predecessor instead is also
  fine. Just bear in mind that, the successor deals with right subtree, while the
  predecessor deals with the left subtree.
- Lazy deletion is also a solution, as an alternative to the deletion above.
  When there requires limited deletion, just mark node as 'deleted' instead of
  really delete it. Lazy deletion saves some extra effort, and avoid the risk of
  constantly changing the tree structure. The performance of BST is highly
  sensitive to its structure, I'll go deep in some future posts.

*** In the End
With all the knowledge mentioned above, I write the complete implementation
code. Checkout my [[https://github.com/muscaestar/algo][Github Repo]]. I also want to append some related leet-code
puzzles here. I'll update this post at a proper time.

This post gives an entry level to the tree structure. Further, I'm planning to analyze
the performance of the BST and discover more about its degeneration. With those
findings, I can write more about the balanced tree, AVL tree, red-black tree, B+
Tree... These advanced trees are gonna be so hard. But they are also must-know, if
you want to understand the performance of modern databases.

*** Reference
- Wikipedia
- Weiss, M. A. (2011). Data structures and algorithm analysis in Java. Pearson.
- 数据结构与算法分析：Java 语言描述（原书第 3 版）/ (美)维斯（ Weiss，M.A.)著；冯舜玺，
  陈越 译. -- 北京：机械工业出版社，2016.2
- [[https://time.geekbang.org/column/intro/126][极客时间－数据结构与算法之美]]

** DONE 算法 Day 1: 二叉树初入门
CLOSED: [2020-02-17 Mon 03:15]
:PROPERTIES:
:EXPORT_FILE_NAME: Musca-Algo-Notes-Day-1
:EXPORT_HUGO_SECTION: zh-CN/post
:EXPORT_HUGO_LOCALE: zh
:END:
就从二叉树开始吧。虽然大多数算法学习材料都从数组、链表开始，但是对于我的学习习惯来
说，从最基础开始容易让我懈怠，拖慢我接受新知识的进度。二叉树是个有趣的起点，它有广泛
的递归使用，需要更多的抽象思考。二叉树的许多变体，是当今工程里普遍使用的热门，比
如红黑树，B＋树等。不过这篇博文属于入门级别，那些高级数据结构就留到之后再说吧。

这篇博文主要会涉及：
1. 二叉树和二叉搜索树的实现
2. 遍历、插入、查找、删除
#+hugo: more
*** 基本术语
**** 树（[[https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)][维基百科]]）
- 是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状
  结构性质的数据集合。它是由 n（n>0）个有限节点组成一个具有层次关系的集合。
***** 树的术语
- 节点：构成树的基本单位
- 根节点：所有节点的祖先节点，没有父节点
- 非终端节点（分支节点）：至少有一个子节点
- 叶节点（终端节点）：没有子节点
- Edge: 两个节点之间的连接
- 深度：对于任意节点 n,n 的深度为从根到 n 的唯一路径长，根的深度为 0
- 高度：对于任意节点 n,n 的高度为从 n 到一片树叶的最长路径长，所有叶节点的高度为 0
- 层：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推。深度＋1；
**** 二叉树（[[https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91][维基百科]]）
- 二叉树是每个节点最多只有两个子节点的树结构。通常分支被称作“左子树”或“右子树”。

**** 二叉搜索树（[[https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9][维基百科]]）
- 二叉搜索树是指一棵空树或者具有下列性质的二叉树：
  - 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值
  - 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值
  - 任意节点的左、右子树也分别为二叉查找树
- 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。
*** 二叉树的实现
二叉树有数组实现和链式实现两种方式。通常来说，链式实现是二叉树，以及普通二叉搜索
树的常见实现方式，从定义的角度看，链式实现更为直观。而堆，一种特殊的完全二叉树，
通常使用数组实现。

这里使用链式，定义一个实现二叉树的类 =BinaryTree= 。内嵌类实现节点 =Node= 。节点
的域包含指向两个子节点的引用，以及一个泛型类型的域。

#+BEGIN_SRC java
public class BinaryTree<E> {
    //only one property
    private Node<E> root;

    //nested Node class
    static class Node<E> {
        E element;
        Node<E> leftNode;
        Node<E> rightNode;
        //constructor, getter, setter
    }

    //more...
}
#+END_SRC
*** 二叉树的遍历（[[https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86][维基百科]]）
**** 遍历的种类
- 深度优先遍历
  - 前序遍历
  - 中序遍历
  - 后序遍历
- 广度优先遍历
  - 层序遍历
**** 使用递归实现遍历
深度优先的遍历是最常见的，可以通过递归的方式，直观又简洁地实现出来。广度优先的遍
历稍显不用，可以将树视为图，进行遍历，这个可以等到和图的知识一起说。这里就关注于
三种深度优先遍历的实现。

递归和传统迭代都可以实现遍历，递归更优雅简洁。学习递归没有捷径，只能不断去尝试使
用它，二叉树可以作为一个很好的递归练习对象。因此，本文选择使用递归实现遍历，和其
他基础操作。

简单分析一下三种基本遍历，其实它们可以被看做是三个操作的不同顺序组合（ N 表示当前
节点）：
- L：递归遍历左（Left）子树
- R：递归遍历右（Right）子树
- N：处理当前节点 N

根据上述定义，三种基本遍历也可以被表示为：
- 前序遍历＝NLR
- 中序遍历＝LNR
- 后序遍历＝LRN

值得注意的是，虽然这三种遍历中，处理 N 的时机不同，但是前 L 后 R 的顺序的不会改变的。
由此可以知道，对一个二叉树执行这三种遍历的过程中，递归函数的入栈出栈顺序，一定都是相同的。

掌握三种遍历的方法很简单，拿出纸笔自己画图实现几次就可以了。注意在画图的过程中，
记录三个方面：
- 各递归函数入栈的时机
- 各递归函数出栈的时机
- 各节点处理（打印）的时机

***** NLR：前序遍历
#+BEGIN_SRC java
public void preOrder(Node<E> N) {
    if (N == null) {
        return;
    }
    doSomething(N); // N
    preOrder(N.leftNode); // L
    preOrder(N.rightNode); // R
}
#+END_SRC

***** LNR：中序遍历
#+BEGIN_SRC java
public void inOrder(Node<E> N) {
    if (N == null) {
        return;
    }
    inOrder(N.leftNode); // L
    doSomething(N); // N
    inOrder(N.rightNode); // R
}
#+END_SRC
***** LRN：后序遍历
#+BEGIN_SRC java
public void postOrder(Node<E> N) {
    if (N == null) {
        return;
    }
    postOrder(N.leftNode); // L
    postOrder(N.rightNode); // R
    doSomething(N); // N
}
#+END_SRC
*** 二叉搜索树的基本操作
二叉搜索树的基本结构和二叉树相似。对于一个储存整数的二叉搜索树，通过中序遍历，
可以得到由这个树的所有节点的值组成的有序数列。由于二叉搜索树的结构和每个节点的数值相关，因此插入、查找、
删除也需要遵循一定的规则。
**** 定义二叉搜索树
与二叉树基本相同。值得注意的是， =BinarySearchTree= 类使用了带有限制的通配符，要
求泛型类型实现或其父类实现 =Comparable= 接口。因为排序需要比较，所以这是一个很自
然的定义。
#+BEGIN_SRC java
public class BinarySearchTree<E extends Comparable<? super E>>() {

    // same as Binary Tree
    private Node<E> root;

    // same as Binary Tree
    static class Node<E>() {
        E element;
        Node<E> leftNode;
        Node<E> rightNode;
        // getters, setters, constructors
    }

    public void printSortedEle() {/* in-order traversal */}

    public Node<E> insert(E x) {...}
    public Node<E> find(E x) {...}
    public Node<E> delete(E x) {...}

    public Node<E> findMin() {...}
    public Node<E> findMax() {...}

    /*other methods*/
}

#+END_SRC
**** 插入操作：递归方式
使用递归时，方法过载是个常见的技巧。下列操作都使用了方法过载。

插入操作的逻辑如下：
- 递归步骤：
  1. 如果要插入的数据 =x= 比根节点的值小，那就在左子树中递归插入；否则，在右子树。然
     后重设子树的根节点。
  2. 如果要插入的数据 =x= 等于根节点的值，什么都不做。
  3. 最后，返回根节点。
- 基准情况：
  1. 根节点为空，用数据 =x= 创建一个新节点并将其返回（新节点就是当前子树的根节点）。

#+BEGIN_SRC java
public Node<E> insert(E x) {
    return insert(x, root);
}

public Node<E> insert(E x, Node<E> root) {
    /* validate argument */

    if (root == null) {
        return new Node<>(x);
    }

    int cmp = x.compareTo(root.element);
    if (cmp < 0) {
        root.leftNode = insert(x, root.leftNode);
    } else if (cmp > 0) {
        root.rightNode = insert(x, root.rightNode);
    } else { /* cmp == 0, do nothing */ }

    return root;
}


#+END_SRC
**** 查找操作：递归方式
查找的基本逻辑也很简单：
- 递归步骤:
  1. 如果要查找的数据 =x= 比根节点的值小，那就在左子树中递归查找；否则，在右子树。然
     后返回下一个递归的值。
- 基准情况:
  1. 如果要查找的数据 =x= 等于根节点的值，返回当前根节点（也就是想要查找的节点）。
  2. 根节点为空，返回空值（表示想要的节点不存在）。

#+BEGIN_SRC java
public Node<E> find(E x) {
    return find(x, root);
}

public Node<E> find(E x, Node<E> root) {
    /* validate agrument */

    if (root == null) {
        return null;
    }
    int cmp = x.compareTo(root.element);
    if (cmp < 0) {
        return find(x, root.leftNode);
    } else if (cmp > 0) {
        return find(x, root.rightNode);
    } else { // cmp == 0
        return root;
    }
}
#+END_SRC
**** 删除操作：递归方式
和很多数据结构一样，删除操作有些麻烦。有三种情况需要考虑：
- 递归步骤:
  1. 如果要删除的数据 =x= 比根节点的值小，那就在左子树中递归删除；否则，在右子树。
     然后重设子树的根节点。
  2. 如果要删除的数据 =x= 等于根节点的值，那就检查根节点的子节点：
     1. 如果根有
        *两个子节点*, 找到根的后继节点。赋予根节点以后继节点的值，接着删
        除后继节点。然后重设右子树的根节点。（虽然要‘删除’的是当前根节点，但实际
        上，这个节点并不会被删除，我们只是更改这个节点储存的数值。而后继节点，是
        真的被删除了，即没有指针指向它）。
     2. 基准情况 1.
     3. 基准情况 2.
  3. 最后，返回根节点。
- 基准情况:
  1. 如果根有
     *一个子节点*, 使这个子节点成为该子树的根。然后返回这个新的根。
  2. 如果根
     *没有子节点*, 那么使这个根为空（即删除这个节点）然后返回这个根（空）。
  3. 如果根为空，那么返回空。（这个情况发生在，当要删除的数据不存在于树中，因此
     树没有任何改动）。

#+BEGIN_SRC java
public Node<E> delete(E x) {
    root = delete(x, root);
    return root;
}

public Node<E> delete(E x, Node<E> root) {
    /* validate argument */

    if (root == null) {
        return null;
    }
    int cmp = x.compareTo(root.element);
    if (cmp < 0) {
        root.leftNode = delete(x, root.leftNode);
    } else if (cmp > 0) {
        root.rightNode = delete(x, root.rightNode);
    } else { // cmp == 0, so going to delete root

        if (root.leftNode != null && root.rightNode != null) { // two children
            // pick root's successor, replace root's element with successor's,
            // then delete successor
            // otherwise, picking root's predecessor also work

            // find the minimal node's element of right subtree
            E newEleOfRoot = findMin(root.rightNode).element;
            root.element = newEleOfRoot;
            root.rightNode = delete(newEleOfRoot, root.rightNode);

        } else if (root.leftNode != null || root.rightNode != null) {
            // one child, just use it to replace root
            root = (root.leftNode != null) ? root.leftNode : root.rightNode;

        } else { // no child, just delete root
            root = null;
        }
    }
    return root;
}
#+END_SRC
**** 基本操作的总结
- 当单个递归方法不使用于常规调用时，可以使用方法过载，定义一个递归方法的同名常规
  方法。这个同名方法将被用于外界的调用，而这个同名方法的内部，将调用这个递归方法。
- =insert(E x)= 和 =delete(E x)= 返回的值是不必要的，因为它们最终返回的就是这个
  树的根节点。根据不同的情况可以任意选择实现返回或不返回，无伤大雅。
- 在上述删除操作中，当需要被删除的节点有两个子节点的情况下，选择了这个节点的后继
  节点去进行一系列操作。实际中，也可以选择前驱节点。只要记得后继节点对应右子树的
  操作，而前驱节点对应左子树的操作，就可以了。
- 除了上述删除操作的实现，
  *懒惰删除* 也是个可行的办法，即并非真的删除节点，而是在相
  应的节点上标记已删除。在删除操作有限的情况下，懒惰删除更加高效省力，也在一定程
  度上规避了由动态更新导致的性能退化。二叉搜索树的性能十分依赖于自身的结构，这也
  是为什么需要更高级更复杂的树结构，详细内容就交给以后的博文介绍吧。
*** 写在最后
根据本文的知识点，我写了完整的代码实现，放在[[https://github.com/muscaestar/algo][Github Repo]]. 我还准备收集一些与本文
相应的 Leet-Code 题目，届时更新在这里。

本篇博文介绍了二叉树知识的初级入门。有关二叉树的进一步学习，会涉及到二叉搜索树的
性能分析和动态更新对性能的影响。由此更进一步，就会涉及到一系列平衡二叉搜索树，
AVL 树，红黑树，B＋树等等。这些高级的树型结构，不是那么容易掌握的。但是对于软件工
程师，想要真正认识大型数据库的结构和性能，高级树知识是一定
*必不可少的！*
*** 参考资料
- Wikipedia
- Weiss, M. A. (2011). Data structures and algorithm analysis in Java. Pearson.
- 数据结构与算法分析：Java 语言描述（原书第 3 版）/ (美)维斯（ Weiss，M.A.)著；冯舜玺，
  陈越 译. -- 北京：机械工业出版社，2016.2
- [[https://time.geekbang.org/column/intro/126][极客时间－数据结构与算法之美]]
* DONE Algo Day 2: Start with Binary Heap / 算法 Day 2: 二叉堆的初入门 :Algorithm:
CLOSED: [2020-02-21 Fri 01:39]
** DONE Algo Day 2: Start with Binary Heap
CLOSED: [2020-02-21 Fri 01:39]
:PROPERTIES:
:EXPORT_FILE_NAME: Musca-Algo-Notes-Day-2
:EXPORT_HUGO_SECTION: en/post
:END:
Last time, I mentioned heap as an array implementation of a complete tree. This
post I'll look closer to the heap. What is it? Why using it? Any real-life
application? I'll cover these in general, and then implement a simple binary
min-heap with basic operations, learning from the best, Java source code. The
topics are as following:
1. Heap is not that Heap
2. Heap is a Tree
3. Heap and Priority Queue
#+hugo: more
*** Heap is not that Heap
What does this sub-title mean? It comes from one of my stupid questions: There's
a term /JVM Stack/ in JVM, using the data structure stack. So, what does the
data structure heap do with the /Heap/ of JVM?

The answer is 'surprisingly': nothing at all. This heap has nothing to do with that heap.

I don't feel bad about myself with this misunderstanding, as I believe many
people like me, with no fundamental CS background, may come up with the same
problem. The good news is, we can search. If we can search, we finally get the right
answer. After all, 'stupid' questions make us less stupid.
**** So, what is Heap?
The meanings of heap differ from their context. When we talking about computer
memory management, /Heap/, also called /free store/, is "an area of memory for
dynamic memory allocation". When we talking about algorithms and data structure,
/Heap/ refers to "a specialized tree-based data structure which is essentially an almost
complete tree that satisfies the heap property". (From [[https://en.wikipedia.org/wiki/Heap][WIKIPEDIA]])

Is it all? No. Because when people talk about /Heap/, they mean /Binary Heap/,
one of the common variants of heap. And also, almost any kinds of heap has two
types, max-heap and min-heap.
*In a max(min) heap, for any non-leaf node, its value must greater(less) than or
equal to any of its descendants.*
So, the top node, or called root node, must be the
greatest(least) node in the heap.

My point, we need to be preciser. I'll use *Binary Min-Heap* or Binary Max-Heap
to describe the exact data structure.
**** Why using Heap?
Let me simply list what can a heap or several heaps do. I'll skip the
details. Maybe write about some of them in the future:
1. Heapsort (I'll definitely cover it when taking about sorting)
2. Used in Dijkstra's algorithm, and other graph algorithms
3. Selecting k-th element. Selecting top-k elements. So-called selection algorithms
4. K-way merge algorithms
5. Priority Queue (later in this article)
*** Heap is a Tree
Now we go a little bit closer. Picturing it. *In mind*.

I know some images in the article may help. I just assuming the readers have
checked the [[https://en.wikipedia.org/wiki/Binary_heap][Wikipedia]]. For simple ADTs like stack, queue, tree, heap... Once you
see the image somewhere, they just stored in your mind. Just treat it as a brain exercise.

**** Two properties of Binary Heap
The following properties make an array a heap logically. We need to strictly
follow them, as every time an operation mess it up, these rules help us
re-arrange things. I'll try to make the rules as short as possible.
***** Structure property
Binary Heap must be a [[https://en.wikipedia.org/wiki/Binary_tree#complete][complete binary tree]].
***** Heap-order property
Any parent node must =<== (or =>==) its children.
**** Array implementation
I haven't talked about the reason for array implementation. In the post of BST,
linked nodes are preferred. Why array this time?

Because a heap is always a complete tree. And a complete tree is perfect for
array storage. Allow me to explain more:

For every layer of a complete tree, you can count from left to right, start to
end, there's no empty position. In this case, if we store the elements in array, layer
by layer, left to right, there should be no empty entry in the middle of an
array. It utilizes the storage space effectively.

There're two styles of this implementation. Each has its own sweetness. I'll
use "Root-One-Style". Also, I named them on my own, so it makes sense
if you never heard of the name (but the implementations truly exist).

***** Root-One-Style
- =array[0]= is =null=
- =array[1]= is element of root node
- given a node at index *i*
  - parent   index: *i / 2*
  - children index: *2i*, *2i + 1*

***** Root-Zero-Style
- =array[0]= is element of root node
- given a node at index *i*
  - parent   index: *(i-1) / 2*
  - children index: *2i + 1*, *2i + 2*
**** Basic operations
The basic operations of a binary heap is insert, extract and build. I'll sneak in
the Java source code for exact implementation in the next section. Before that,
I want to set the basic concept of the logic flow of all three operations:
1. Put-in or take-out nodes
2. Messed up (Current 'heap' is not a heap)
3. Heapify it
**** Heap is unsorted
This is just a fact. I want to bring it up, because when we think about a binary
heap, we tend to compare it with a BST. While BST is sorted, heap is not. Also, heap is
unsorted, so the siblings are not sorted at all. Sometimes, it is easy to
ignore it.

*** Heap and Priority Queue
Finally, we can write code. Let's checkout Java source code of [[https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/PriorityQueue.java][PriorityQueue]].
But wait, why priority queue?

*TL;DR. If we are only looking for a way to implement a binary min-heap,
just 'mock' Java's PriorityQueue.*

As we mentioned before, priority queue is an application of a binary heap,
specifically, a binary min-heap. And in fact, the only difference between a priority
queue and a binary min-heap, is just their concepts. If we only compare the
code, they could be exactly the same.

Ok, concepts are different. So how to define a priority queue? In a priority
queue, an element with high priority is served before an element with low
priority (From [[https://en.wikipedia.org/wiki/Priority_queue][WIKIPEDIA]]). Quote from [[https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html][Java API]], "An unbounded priority queue based on a
priority heap."

**** Class structure
After reading the source code of PriorityQueue times and times, I came up with
this structure. I try to make it simpler, as it is mainly for beginners to
understand the binary heap. Here're some highlights:
1. I utilize the generic type to define the array, while Java uses =Object[]=.
   Many reasons underneath. My choice only needs type casting once, which
   happens in constructor.
2. Type bound and wildcard used, to make sure that E must be a subclass of some
   class that implements Comparable Interface. Note that Java source code is
   more complex, as it considers both Comparable and Comparator in reality use cases.
3. The capacity is fixed. Of course, I can give it a dynamic growing feature, but
   I just leave it be.
#+BEGIN_SRC java
public class BinaryMinHeap<E extends Comparable<? super E>> {
    private E[] array; // store elements, start from index 1
    private int size; // number of elements stored
    private int capacity; // length of array - 1

    public BinaryMinHeap(int capacity) {/*  */}
    public BinaryMinHeap(int capacity, E[] rawArray) {/* build() */}

    public E add(E e) {/* siftUp() */}
    public E poll() {/* siftDown() */}

    private int siftUp(int i, E e) {/*  */}
    private int siftDown(int i, E e) {/*  */}
    private boolean build() {/* siftDown() */}

    // other methods
}
#+END_SRC
**** Heapify
I mentioned /Heapify/ in the last section. The main function of heapify is,
re-arrange the structure of heap, to make sure it satisfies two properties.
In the end, there're two methods to heapify, sift-up and sift-down. They are the
crucial, because most operations need them. Once you understand them, other operations are easy.

As you can see, =siftUp()= and =siftDown()= are two internal operations of the
Heap class. Before calling them, you need to do proper preprations.

Note that, for one calling of the sift-up/down, there may happen
*0 time or multiple times* of parent-child-swap.
***** Sift-up
There're lots of names for it: up-heap, bubble-up, percolate-up, sift-up, trickle-up, swim-up, heapify-up, cascade-up.

Let the code speaks. And I also document it, so allow me to just leave it be.

#+BEGIN_SRC java
/**
 * Heapify-up the heap.
 * At the start of this method, the 'heap' has an empty node.
 * This method re-allocate the empty node by keeping comparing it
 * with its parent, then swap if need.
 * After re-allocation, fill element e into it.
 *
 * @param i the index of empty node
 * @param e the element going to fill in
 * @return the final index of original empty node
 */
private int siftUp(int i, E e) {
    while (i > 1) { // while the empty node is not the top
        int parent = i / 2;

        int cmp = e.compareTo(array[parent]);
        if (cmp < 0) {
            array[i] = array[parent];
            i = parent;
        } else { // cmp >= 0
            break;
        }
    }
    array[i] = e; // fill the empty node with e
    return i;
}
#+END_SRC

***** Sift-down
Also lots of names: down-heap, bubble-down, percolate-down, sift-down, sink-down, trickle down, heapify-down, cascade-down.

A bit more complicated than sift-up, because it requires a comparison between
two children.

Also just let the code speaks...

#+BEGIN_SRC java
/**
 * Heapify-down the heap.
 * At the start of this method, the 'heap' has an empty node.
 * This method re-allocate the empty node by keeping comparing it
 * with its least child, then swap if need.
 * After re-allocation, fill element e into it.
 *
 * @param i the index of the empty node
 * @param e the element going to fill in
 * @return the final index of the original empty node
 */
private int siftDown(int i, E e) {
    while (i <= size / 2) { // make sure empty node is non-leaf
        int ch1 = i * 2; // index of child 1
        int ch2 = ch1 + 1; // index of child 2, if exist

        int leastChild = ch1;
        // if ch2 exist, then compare children to get the least one
        if (ch2 <= size && array[ch1].compareTo(array[ch2]) > 0) {
            leastChild = ch2;
        }

        int cmp = e.compareTo(array[leastChild]);
        if (cmp > 0) {
            E tmp = array[leastChild];
            array[leastChild] = array[i];
            array[i] = tmp;
            i = leastChild;
        } else {
            break;
        }
    }
    array[i] = e; // fill the empty node with e
    return i;
}
#+END_SRC

**** Insert operation
Steps:
1. size plus one
2. pick the empty node and e
   - empty node: tail
   - e: argument
3. sift-up
#+BEGIN_SRC java
public E add(E e) {
    /* validation checking */

    // size plus one, and make tail be the empty node
    int i = size + 1; // index of empty node
    if (size++ == 0) { // check if heap is empty, then add size
        array[i] = e;
    }
    i = siftUp(i, e);
    return array[i]; // the e just added
}
#+END_SRC
**** Extract/Poll operation
Steps:
1. size minus one
2. pick the empty node and e
   - empty node: top
   - e: tail
3. sift-down
#+BEGIN_SRC java
public E poll() {
    E res = array[1];
    array[1] = null; // make top be the empty node

    E e = array[size]; // the value of tail node will be fill in later
    array[size--] = null; // remove the tail node, size - 1

    siftDown(1, e);
    return res;
}
#+END_SRC
**** Build operation
I let the =build()= be a private method. It only gets called by the constructor,
when the argument contains a raw array.
Steps:
1. for each non-leaf node, index number from big to small
   - pick empty node and e
     - empty node: current non-leaf node
     - e: current non-leaf node
   - sift-down
2. until loop ends

#+BEGIN_SRC java
private boolean build() {
    for (int i = size / 2; i >= 1; i--) {
        siftDown(i, array[i]);
    }
    return true;
}
#+END_SRC
*** In the End
With all the knowledge mentioned above, I write the complete implementation
code. Checkout my [[https://github.com/muscaestar/algo][Github Repo]].
*** Reference
- Wikipedia
- Weiss, M. A. (2011). Data structures and algorithm analysis in Java. Pearson.
- Java™ Platform, Standard Edition 7, API Specification
- [[https://hg.openjdk.java.net/][OpenJDK]]
- 数据结构与算法分析：Java 语言描述（原书第 3 版）/ (美)维斯（ Weiss，M.A.)著；冯舜玺，
  陈越 译. -- 北京：机械工业出版社，2016.2
- [[https://time.geekbang.org/column/intro/126][极客时间－数据结构与算法之美]]

** DONE 算法 Day 2: 二叉堆的初入门
CLOSED: [2020-02-21 Fri 01:39]
:PROPERTIES:
:EXPORT_FILE_NAME: Musca-Algo-Notes-Day-2
:EXPORT_HUGO_SECTION: zh-CN/post
:EXPORT_HUGO_LOCALE: zh
:END:
上一篇博文中，我提到了一种通常用数组实现的完全树，那就是堆。今天这篇文章，我就来
关注一下堆的知识。什么是堆？为什么使用堆？堆的实际应用？我会尝试一一解答。最后当
然是，通过代码去实现一个简单的最小二叉堆，并且参考一下 Java 源码。文章内容如下：
1. 此堆非彼堆
2. 堆是一颗树
3. 堆和优先队列
#+hugo: more
*** 此堆非彼堆
从何说起呢？一切都始于我的一个小小的无知：JVM 里有个方法栈，用了 栈 这个数据结构；这么
说来 JVM 里还有个堆，那它就用了 堆 这个数据结构咯？

正确答案‘竟然’是：错错错错。这两个堆，半毛钱关系都没有。

自从开始认真学习 IT 以来，我已经习惯于每天都认识到自己的无知了。我觉得知道自己无知，
不是什么坏事，没什么大不了的。我猜大概很多像我一样，不是科班出身的朋友，都会
遇到类似的问题。这也没什么不好的，不懂就去查嘛，越查就懂得越多了。所以我觉得，认
识到自己无知，是变聪明的开始。
**** 所以，堆是什么？
不同知识领域下，堆指代了不同的事物。在计算机内存领域里，堆，是一块服务于动态内存管
理的内存区域。而在算法与数据结构领域里，堆，指一种特别的树状数据结构，满足完全树
的特征，和堆序性质。（参见[[https://en.wikipedia.org/wiki/Heap][维基百科]]）

这还不是全部。通常来说，在算法里提起堆这个词，其实指的是
*二叉堆*, 它是比较常用到的一个堆的变体。还有，一个堆也分最小堆和最大堆，也叫小顶
堆和大顶堆。
*给定小顶堆中的任意节点，那么该节点一定小于或等于它的所有后代节点；反之，给定大
顶堆，那么该节点一定大于等于所有后代*
也就是说，顶节点，或称根节点，一定是这个堆中最小（大）的。

我觉得严谨不会有什么坏处，因此接下来我会使用完整的描述来指代特定堆，比如最小
二叉堆，最大二叉堆。
**** 为什么用堆？
这是很大的话题，这里我就简单罗列一下堆的应用。将来有机会，我会针对性地写博文：
1. 堆排序（写排序时，我一定会涉及堆排）
2. 狄克斯特拉算法，和其他图的算法
3. 选择算法，如第 k 个值，前 k 个值
4. k 路归并算法
5. 优先队列（本文会涉及）
*** 堆是一颗树
下面我们说得更细一些，需要在
*脑海中*
想象。

虽然我也承认插个图片更方便些，不过我还是不插图了。在我的观念中，像栈，队列，树，
堆这些简单的数据结构，第一次学看过一遍后，到哪里都不会忘的。就算忘了，这种图随便
一搜都是...等敲代码的时候，一般都是自己在脑子里想象。所以，就当脑力锻炼吧。

**** 二叉堆的两个性质
在逻辑上构建数据结构，必须需要严格的规则。性质决定了具体的规则，它能帮助你确保数
据结构在动态变化中，保持应有的结构。二叉堆的性质有两个，为了方便记忆，我用最短的
语言描述它们：
***** 结构性质
二叉堆必须是一个[[https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91][完全二叉树]]。
***** 堆序性质
任何父节点必须 =<== （或 =>== ）它的子节点。
**** 数组实现
说了这么多，还没有讲到究竟为什么是使用数组实现。在入门二叉搜索树的文章中，使用了
链式储存的思路实现了树。为什么这次用堆？

因为堆始终是一个完全树，而一个完全树是最适合使用的数组实现的。再进一步解释一下：

对于一个完全树的每一层，从层的头部到尾部，从左依次到右，不会遇到空位，即层是满的。
就算是‘不满’的最底层，从最左节点到最右边的节点之间，也不会有空位。在这种情况下，
我们一层一层地把节点值存入数组中，从第一个值到最后一个值之间，都不会出现空位。这
种结构最大限度地利用了数组的每一个空间。

数组实现有两种方案，各有各的优缺点。接下来的实现中我会选择从下标 1 开始储存的方案。
***** 从下标 1 开始储存
- =array[0]= 是 =null=
- =array[1]= 是根节点
- 对于在下标 *i* 处的节点
  - 父节点下标: *i / 2*
  - 子节点下标: *2i*, *2i + 1*

***** 从下标 0 开始储存
- =array[0]= 是根节点
- 对于在下标 *i* 处的节点
  - 父节点下标: *(i-1) / 2*
  - 子节点下标: *2i + 1*, *2i + 2*
**** 基本操作
二叉堆的基本操作为：插入，删除堆顶，建堆。我准备下一节结合 Java 源码描述每个操作的
实现。在这之前，我想先把最基本的操作思路流程写在这里，因为每种基本操作都是这个思
路：
1. 插入或移出节点
2. 基本性质被破坏
3. 堆化（恢复基本性质）
**** 堆的内部是无序的
这是一个很自然的事实。不过我还是想要提一遍，因为当我们思考二叉堆的时候，会不自觉地把
二叉堆和二叉搜索树联系起来。二叉搜索树内部是有序的，而二叉堆的内部是无序的。由于
堆内是无序的，所以堆内的兄弟节点间没有排序。一不小心很容易忽略这个事实。

*** 堆和优先队列
终于要轮到代码了。先去看看千锤百炼的 Java 源码的优先队列：[[https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/PriorityQueue.java][PriorityQueue]]. 不过在
这之前，还是得自问，为什么看优先队列呢？

*太长不看版：如果仅仅是为了学习最小二叉堆的代码实现，直接模仿 Java 的优先队列没问
 题。*

刚刚提到过，优先队列是二叉堆，准确说，最小二叉堆。事实上，优先队列和最小二叉堆的
唯一区别，那就是概念上的区别。如果单单看代码，这两个的代码实现可以是几乎一模
一样的。

前面说到是概念上的区别，那么这里借用[[https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97][维基百科]]定义一下优先队列：优先队列中的每个元
素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先
队列中的顺序得到服务。而在 [[https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html][Java API]] 中也写道，"An unbounded priority queue based on a
priority heap."

**** 类的结构
经过对源码的阅读和理解，我写出了如下的最小二叉堆结构。力求简洁，主要目的还是核心
概念的理解，因此省去了一些功能。提几个要点：
1. 我的数组使用了泛型类型，而 Java 源码实际上直接用 =Object[]= 。无知如我，我只能大致
   猜想开发者的意图。不过我直接用泛型的原因是，这种实现只需要在构造器中做一次强
   制类型转换即可。
2. 对泛型使用类型界限和通配符，确保 E 类的父类一定实现了 Comparable 接口。Java 源码在这方
   面考虑更全面，Comparable 和 Comparator 的情况都覆盖到了。
3. 没有实现动态括容。因为我觉得这不是必备功能，为了简洁，就放弃了。实际情况下当
   然是动态扩容更好些。
#+BEGIN_SRC java
public class BinaryMinHeap<E extends Comparable<? super E>> {
    private E[] array; // store elements, start from index 1
    private int size; // number of elements stored
    private int capacity; // length of array - 1

    public BinaryMinHeap(int capacity) {/*  */}
    public BinaryMinHeap(int capacity, E[] rawArray) {/* build() */}

    public E add(E e) {/* siftUp() */}
    public E poll() {/* siftDown() */}

    private int siftUp(int i, E e) {/*  */}
    private int siftDown(int i, E e) {/*  */}
    private boolean build() {/* siftDown() */}

    // other methods
}
#+END_SRC
**** 堆化
上一节我提到了堆化这个词。堆化的主要功能是，修复被破坏的两个基本性质。堆化这个操
作再细分下来，分为上滤（Sift-up）和下滤（Sift-down），也可以叫向上堆化和向下堆化。在我看来，这是二叉堆一
切操作的核心，因为几乎所有的操作都要用到它。掌握好它，其他操作就变得简单多了。

在我写的类结构中， =siftUp()= 和 =siftDown()= 作为 private 方法，也符合它们本身作
为内部操作的定义。在调用它们之前，实例内部需要达到一定的条件，这也是封装它们的理
由之一。

有一点需要注意，调用一次上滤（或下滤）时，内部发生的“父子调换”，可能的次数是
*0 次或多次*.

***** 上滤
上滤的英文称呼很多，这里特别记录一下：up-heap, bubble-up, percolate-up, sift-up,
trickle-up, swim-up, heapify-up, cascade-up。

代码该注释的都注释了，我觉得这比文字图片都更好理解。

#+BEGIN_SRC java
/**
 * Heapify-up the heap.
 * At the start of this method, the 'heap' has an empty node.
 * This method re-allocate the empty node by keeping comparing it
 * with its parent, then swap if need.
 * After re-allocation, fill element e into it.
 *
 * @param i the index of empty node
 * @param e the element going to fill in
 * @return the final index of original empty node
 */
private int siftUp(int i, E e) {
    while (i > 1) { // while the empty node is not the top
        int parent = i / 2;

        int cmp = e.compareTo(array[parent]);
        if (cmp < 0) {
            array[i] = array[parent];
            i = parent;
        } else { // cmp >= 0
            break;
        }
    }
    array[i] = e; // fill the empty node with e
    return i;
}
#+END_SRC
***** 下滤
相对应上滤，以下是下滤的英文称呼：down-heap, bubble-down, percolate-down,
sift-down, sink-down, trickle down, heapify-down, cascade-down。

下滤稍微更麻烦一点，因为需要对比两个子节点。

注释完整的代码如下。

#+BEGIN_SRC java
/**
 * Heapify-down the heap.
 * At the start of this method, the 'heap' has an empty node.
 * This method re-allocate the empty node by keeping comparing it
 * with its least child, then swap if need.
 * After re-allocation, fill element e into it.
 *
 * @param i the index of the empty node
 * @param e the element going to fill in
 * @return the final index of the original empty node
 */
private int siftDown(int i, E e) {
    while (i <= size / 2) { // make sure empty node is non-leaf
        int ch1 = i * 2; // index of child 1
        int ch2 = ch1 + 1; // index of child 2, if exist

        int leastChild = ch1;
        // if ch2 exist, then compare children to get the least one
        if (ch2 <= size && array[ch1].compareTo(array[ch2]) > 0) {
            leastChild = ch2;
        }

        int cmp = e.compareTo(array[leastChild]);
        if (cmp > 0) {
            E tmp = array[leastChild];
            array[leastChild] = array[i];
            array[i] = tmp;
            i = leastChild;
        } else {
            break;
        }
    }
    array[i] = e; // fill the empty node with e
    return i;
}
#+END_SRC
**** 插入新元素
步骤简述：
1. size 加一
2. 选择两个上滤的参数
   - 目标节点：尾部节点
   - e：插入方法的参数
3. 上滤
#+BEGIN_SRC java
public E add(E e) {
    /* validation checking */

    // size plus one, and make tail be the empty node
    int i = size + 1; // index of empty node
    if (size++ == 0) { // check if heap is empty, then add size
        array[i] = e;
    }
    i = siftUp(i, e);
    return array[i]; // the e just added
}
#+END_SRC
**** 删除堆顶元素
步骤简述：
1. size 减一
2. 选择两个下滤参数
   - 目标节点：顶部节点
   - e：尾部节点元素
3. 下滤

#+BEGIN_SRC java
public E poll() {
    E res = array[1];
    array[1] = null; // make top be the empty node

    E e = array[size]; // the value of tail node will be fill in later
    array[size--] = null; // remove the tail node, size - 1

    siftDown(1, e);
    return res;
}
#+END_SRC
**** 建堆
我的代码实现里， =build()= 是 private 方法。它只会在一个构造器里被调用。
步骤简述：
1. 遍历每一个非叶子节点，顺序是下标从大到小
   - 选择两个下滤参数
     - 目标节点：当前非叶子节点
     - e：当前非叶子节点的元素
   - 下滤
2. 遍历完成
#+BEGIN_SRC java
private boolean build() {
    for (int i = size / 2; i >= 1; i--) {
        siftDown(i, array[i]);
    }
    return true;
}
#+END_SRC

*** 写在最后
根据本文的知识点，我写了完整的代码实现，放在[[https://github.com/muscaestar/algo][Github Repo]].
*** 参考资料
- Wikipedia
- Weiss, M. A. (2011). Data structures and algorithm analysis in Java. Pearson.
- Java™ Platform, Standard Edition 7, API Specification
- [[https://hg.openjdk.java.net/][OpenJDK]]
- 数据结构与算法分析：Java 语言描述（原书第 3 版）/ (美)维斯（ Weiss，M.A.)著；冯舜玺，
  陈越 译. -- 北京：机械工业出版社，2016.2
- [[https://time.geekbang.org/column/intro/126][极客时间－数据结构与算法之美]]
* TODO Algo Day 3: A Peek at Java Collections Framework / 算法 Day 3: 初探 Java 集合框架
** TODO Algo Day 3: A Peek at Java Collections Framework
:PROPERTIES:
:EXPORT_FILE_NAME: Musca-Algo-Notes-Day-3
:EXPORT_HUGO_SECTION: en/post
:END:
I want to learn algorithms with my own understanding, which means not going with
the "classic path", asymptotic analysis, array, linked list, queue, stack, sort, so on. 
I believe this traditional structure does work most of the time, that's why
books and courses all follow it. But I just don't feel right.

Just say, I want to draw my own graph and any vertex could be my start point. As
long as I draw the edges correctly, no matter using DFS or BFS, I can finally
finish the graph, which should theoretically match the common knowledge structure.

So, I'll use Java collections framework as a "guide". Try to figure out the
reasons for combining several ADTs and algorithms in its own way. It also helps
my Java skills. A twofer.
#+hugo: more
*** Heading 1
text

** TODO 算法 Day 3: 初探 Java 集合框架
:PROPERTIES:
:EXPORT_FILE_NAME: Musca-Algo-Notes-Day-3
:EXPORT_HUGO_SECTION: zh-CN/post
:EXPORT_HUGO_LOCALE: zh
:END:
我一直想用自己的理解来学一遍算法，而不是直接跟着“经典”学习路径一路到头，比如从复
杂度分析开始，依次认识数组、链表、栈、队列、等等等等。这是前辈们总结出来的，广泛
适用于大部分学习情况的方法，对肯定是对的。不过从构建我的个人知识框架来说，“对”不够“好”。

可以这么说，我的知识框架是一个图，那么我可以把任何一个顶点作为我的起点。只要能画
对顶点之间的边，无论是深度优先还是广度优先，我最终都能得到一个像样的知识图谱。

于是我决定，将 Java 的集合框架作为目前的“指导手册”。我首先
要做的是，努力搞明白 Java 设计集合框架的思路，为什么用这些数据结构和算法互相组合？
以此学习，算法和 Java 技能都能有所提升，一石二鸟。
#+hugo: more
*** 正文标题 1
正文
* Re-configuration of my CLI setup / 重新配置命令行工具
** TODO Re-configuration of my CLI setup
:PROPERTIES:
:EXPORT_FILE_NAME: Re-config-CLI-setup
:EXPORT_HUGO_SECTION: en/post
:END:
Abstract
#+hugo: more
*** Heading 1
text

** TODO 重新配置命令行工具
:PROPERTIES:
:EXPORT_FILE_NAME: Re-config-CLI-setup
:EXPORT_HUGO_SECTION: zh-CN/post
:EXPORT_HUGO_LOCALE: zh
:END:
前言
#+hugo: more
*** 正文标题 1
正文
